var Board = require("../lib/board.js"),
  events = require("events"),
  util = require("util");

var priv = new WeakMap(),
    steppers = [];

var MAXSTEPPERS = 6; // correlates with MAXSTEPPERS in firmware

/**
 * Stepper - Class for handling steppers using AdvancedFirmata support for asynchronous stepper control
 * @constructor
 *
 * five.Stepper({
 *  type: constant,     // firmata.STEPPER.TYPE.*
 *  stepsPerRev: number,  // steps to make on revolution of stepper
 *  pins: {
 *      dir: number,    // pin attached to direction pin on driver (used for type DRIVER)
 *      step: number,   // pin attached to step pin on driver (used for type DRIVER)
 *      motor1: number, // (used for type TWO_WIRE and FOUR_WIRE)
 *      motor2: number, // (used for type TWO_WIRE and FOUR_WIRE)
 *      motor3: number, // (used for type FOUR_WIRE)
 *      motor4: number, // (used for type FOUR_WIRE)
 *  }
 * });
 *
 * @param {Object} opts
 *
 */

function Stepper( opts ) {
  var params = [];

  if ( !(this instanceof Stepper) ) {
    return new Stepper( opts );
  }

  // Initialize a Device instance on a Board
  Board.Device.call(
    this, opts = Board.Options( opts )
  );

  if ( this.firmata.firmware.name.indexOf("AdvancedFirmata") === -1 ) {
    throw new Error(
      "Stepper requires AdvancedFirmata. https://github.com/soundanalogous/AdvancedFirmata"
    );
  }

  if ( !opts.pins ) {
    throw new Error(
      "Must provide opts.pins for the stepper"
    );
  }

  if ( !opts.stepsPerRev ) {
    throw new Error(
      "Must set stepsPerRev for a stepper"
    );
  }

  this.id = steppers.length;

  if ( this.id >= MAXSTEPPERS ) {
    throw new Error(
      "Unable to configure more than " + MAXSTEPPERS + " steppers"
    );
  }

  // Initial Stepper config params (same for all 3 types)
  params.push( this.id, opts.type, opts.stepsPerRev );


  if ( opts.type === Stepper.TYPE.DRIVER ) {
    if ( !this.pins.dir || !this.pins.step ) {
      throw new Error(
        "Stepper.TYPE.DRIVER expects: pins.dir, pins.step"
      );
    }

    params.push(
      this.pins.dir, this.pins.step
    );
  }

  if ( opts.type === Stepper.TYPE.TWO_WIRE ) {
    if ( !this.pins.motor1 || !this.pins.motor2 ) {
      throw new Error(
        "Stepper.TYPE.TWO_WIRE expects: pins.motor1, pins.motor2"
      );
    }

    params.push(
      this.pins.motor1, this.pins.motor2
    );
  }

  if ( opts.type === Stepper.TYPE.FOUR_WIRE ) {
    if ( !this.pins.motor1 || !this.pins.motor2 || !this.pins.motor3 || !this.pins.motor4 ) {
      throw new Error(
        "Stepper.TYPE.FOUR_WIRE expects: pins.motor1, pins.motor2, pins.motor3, pins.motor4"
      );
    }

    params.push(
      this.pins.motor1, this.pins.motor2, this.pins.motor3, this.pins.motor4
    );
  }

  this.firmata.stepperConfig.apply( this.firmata, params );

  steppers.push(this);

  priv.set(this, {
    isRunning: false,
    rpm: 0,
    speed: 0,
    accel: 0,
    decel: 0,
    direction: -1
  });
};

Object.defineProperties(Stepper, {
  TYPE: {
    value: Object.freeze({
      DRIVER: 1,
      TWO_WIRE: 2,
      FOUR_WIRE: 4
    })
  },
  RUNSTATE: {
    value: Object.freeze({
      STOP: 0,
      ACCEL: 1,
      DECEL: 2,
      RUN: 3
    })
  },
  DIRECTION: {
    value: Object.freeze({
      CCW: 0,
      CW: 1
    })
  }
})


Stepper.prototype.rpm = function( rpm ) {
  var state = priv.get( this );

  if ( typeof rpm === "undefined" ) {
    return state.rpm;
  }
  state.rpm = rpm;
  state.speed = Math.floor( rpm / 60 * (2 * Math.PI) * 100 );
  return this;
};

Stepper.prototype.speed = function( speed ) {
  var state = priv.get( this );

  if ( typeof speed === "undefined" ) {
    return state.speed;
  }
  state.speed = Math.floor(speed);
  state.rpm = Math.floor(speed) / (2 * Math.PI) / 100 * 60;
  return this;
};

["direction", "accel", "decel"].forEach(function( prop ) {
  Stepper.prototype[ prop ] = function( value ) {
    var state = priv.get( this );

    if ( typeof value === "undefined" ) {
      return state[ prop ];
    }
    state[ prop ] = value;
    return this;
  };
});


/**
 * step
 *
 * Move stepper motor a number of steps and call the callback on completion
 *
 * @param {Number} stepsOrOpts Steps to move using current settings for speed, accel, etc.
 * @param {Object} stepsOrOpts Options object containing any of the following:
 *    stepsOrOpts = {
 *      steps:
 *      rpm:
 *      speed:
 *      direction:
 *      accel:
 *      decel:
 *    }
 *
 * NOTE: *steps* is required.
 *
 * @param {Function} callback function(err, complete)
 */
Stepper.prototype.step = function( stepsOrOpts, callback ) {
  var steps, step, state, params, isValidStep;

  steps = typeof stepsOrOpts === "object" ?
    (stepsOrOpts.steps || 0) : Math.floor( stepsOrOpts );

  step = new Step( this );

  state = priv.get( this );

  params = [];

  isValidStep = true;

  function failback() {
    isValidStep = false;
    callback();
  }

  params.push( steps );

  if ( typeof stepsOrOpts === "object" ) {

    // Speed will always override rpm
    if ( typeof stepsOrOpts.rpm !== "undefined" ) {
      this.rpm( stepsOrOpts.rpm );
    }

    // If an object of property values has been provided,
    // call the correlating method with the value argument.
    Step.PROPERTIES.forEach(function( key ) {
      if ( typeof stepsOrOpts[ key ] !== "undefined" ) {
        this[ key ]( stepsOrOpts[ key ] );
      }
    }, this);
  }

  Step.PROPERTIES.forEach(function( key ) {
    params.push( step[ key ] = this[ key ]() );
  }, this);



  if ( steps === 0 ) {
    failback(
      new Error( "Must set a number of steps" )
    );
  }

  if ( step.direction < 0 ) {
    failback(
      new Error( "Must set a direction" )
    );
  }

  if ( step.speed < 0 ) {
    failback(
      new Error( "Must set a speed" )
    );
  }

  if ( isValidStep ) {
    state.isRunning = true;

    params.push(function(complete) {
      state.isRunning = false;
      callback( null, complete );
    });

    step.move.apply( step, params );
  }

  return this;
};

function Step( stepper ) {
  this.direction = -1;
  this.speed = 0;
  this.accel = 0;
  this.decel = 0;

  this.stepper = stepper;
}

Step.prototype.move = function( steps, dir, speed, accel, decel, callback ) {
  // Restore the param order... (steps, dir => dir, steps)
  this.stepper.firmata.stepperStep.apply(
    this.stepper.firmata, [ this.stepper.id, dir, steps, speed, accel, decel, callback ]
  );
};

Step.PROPERTIES = [ "direction", "speed", "accel", "decel" ];

module.exports = Stepper;
